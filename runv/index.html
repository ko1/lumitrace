<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LumiTrace Playground</title>
  <meta name="description" content="Run Ruby in the browser and see traced values inline with lumitrace 0.4.1.">
  <meta property="og:title" content="LumiTrace Playground">
  <meta property="og:description" content="Run Ruby in the browser and see traced values inline with lumitrace 0.4.1.">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://github.com/ko1/lumitrace/tree/master/runv">
  <meta property="og:see_also" content="https://github.com/ko1/lumitrace/tree/master/runv">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/styles/github.min.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Fraunces:wght@500;700&family=IBM+Plex+Mono:wght@400;600&family=Work+Sans:wght@400;600&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/highlight.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/ruby.min.js"></script>
  <style>
    :root {
      --bg: #f3efe6;
      --panel: #ffffff;
      --ink: #1e1d1b;
      --accent: #cf4a2c;
      --muted: #6f6a62;
      --line: #d9d1c6;
      --ok: #1f7a4f;
      --bad: #a6362a;
      --editor-min: clamp(120px, 24vh, 320px);
      --output-min: clamp(120px, 20vh, 160px);
      --annotated-min: clamp(200px, 38vh, 360px);
      --mono: "IBM Plex Mono", ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      --display: "Fraunces", "Georgia", serif;
      --sans: "Work Sans", system-ui, -apple-system, "Segoe UI", sans-serif;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      padding: 24px;
      font-family: var(--sans);
      color: var(--ink);
      background:
        radial-gradient(circle at 12% 15%, rgba(207,74,44,0.12), transparent 40%),
        radial-gradient(circle at 85% 10%, rgba(31,122,79,0.12), transparent 45%),
        linear-gradient(180deg, #f8f5ef 0%, #efe9df 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 16px;
      margin-bottom: 18px;
      border-bottom: 2px solid var(--line);
      padding-bottom: 10px;
    }

    h1 {
      font-family: var(--display);
      font-size: 30px;
      margin: 0;
      letter-spacing: 0.4px;
    }

    .sub {
      color: var(--muted);
      font-size: 14px;
      margin: 0;
    }

    .site-footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      padding-top: 8px;
      border-top: 1px solid var(--line);
      margin-top: 12px;
    }

    .footer-links {
      display: flex;
      align-items: center;
      gap: 16px;
      color: var(--muted);
      font-size: 12px;
    }

    .wrap {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 24px;
      align-items: stretch;
      flex: 1;
      min-height: 0;
    }

    .column {
      display: flex;
      flex-direction: column;
      gap: 24px;
      min-height: 0;
    }

    .column .panel {
      flex: 1;
      min-height: 0;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 16px;
      box-shadow: 0 12px 32px rgba(30, 29, 27, 0.08);
      display: flex;
      flex-direction: column;
      gap: 12px;
      min-height: 0;
    }

    .panel-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .annotated-frame {
      width: 100%;
      border: 1px dashed var(--line);
      border-radius: 10px;
      min-height: var(--annotated-min);
      flex: 1;
      background: #fbfaf7;
    }

    .status {
      font-size: 12px;
      color: var(--muted);
      border: 1px solid var(--line);
      border-radius: 999px;
      padding: 4px 10px;
      background: #f6f1e7;
    }

    .status.ok { color: var(--ok); border-color: rgba(31,122,79,0.3); }
    .status.bad { color: var(--bad); border-color: rgba(166,54,42,0.3); }

    textarea {
      width: 100%;
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 12px;
      font-family: var(--mono);
      font-size: 13px;
      background: #fbfaf7;
      color: var(--ink);
      line-height: 1.5;
      resize: vertical;
    }

    .code-editor {
      position: relative;
      width: 100%;
      flex: 1;
      min-height: var(--editor-min);
      border: 1px solid var(--line);
      border-radius: 10px;
      background: #fbfaf7;
      overflow: hidden;
    }

    .code-editor pre {
      position: absolute;
      inset: 0;
      margin: 0;
      padding: 12px;
      font-family: var(--mono);
      font-size: 13px;
      line-height: 1.5;
      white-space: pre;
      overflow: auto;
    }

    .code-editor textarea {
      position: relative;
      width: 100%;
      height: 100%;
      min-height: 0;
      border: none;
      background: transparent;
      color: transparent;
      caret-color: var(--ink);
      resize: none;
      overflow: auto;
    }

    .editor {
      flex: 1;
      min-height: var(--editor-min);
    }

    .stdin {
      min-height: 90px;
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 10px;
      justify-content: flex-end;
      flex-shrink: 0;
      margin-top: auto;
    }

    .select-wrap {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--muted);
    }

    select {
      border: 1px solid var(--line);
      background: #fbfaf7;
      color: var(--ink);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      font-family: var(--sans);
    }

    button {
      border: 1px solid var(--accent);
      background: var(--accent);
      color: #fff;
      padding: 8px 18px;
      border-radius: 999px;
      font-size: 13px;
      cursor: pointer;
      font-weight: 600;
      letter-spacing: 0.2px;
    }

    button:disabled {
      cursor: not-allowed;
      opacity: 0.6;
    }

    .output-block {
      border: 1px dashed var(--line);
      border-radius: 10px;
      padding: 12px;
      background: #fbfaf7;
      font-family: var(--mono);
      font-size: 12px;
      white-space: pre-wrap;
      min-height: var(--output-min);
      flex: 1;
      overflow: auto;
    }

    .label {
      font-weight: 600;
      font-size: 12px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    @media (max-width: 900px) {
      .wrap {
        grid-template-columns: 1fr;
        flex: 0 0 auto;
      }
      .panel {
        min-height: auto;
      }
    }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>LumiTrace Playground</h1>
      <p class="sub">Run Ruby in the browser and see traced values inline with lumitrace 0.4.1.</p>
    </div>
  </header>

  <main class="wrap">
    <section class="column">
      <section class="panel">
        <div class="panel-head">
          <div class="label">Editor</div>
          <span class="status" id="runStatus">Idle</span>
        </div>
        <div class="code-editor editor">
        <pre id="rubyHighlight" class="hljs"></pre>
        <textarea id="rubyInput" spellcheck="false">def square(n)
  if n > 0
    n > 0 ? n * n : raise
  else
    n
  end
end

def sum_of_squares(limit)
  total = 0
  (1..limit).each do |i|
    total += square(i)
  end
  total
end

def report(limit)
  puts "Squares:"
  (1..limit).each do |i|
    puts "  #{i}^2 = #{square(i)}"
  end
  puts "Sum: #{sum_of_squares(limit)}"
end

report(5)</textarea>
        </div>

        <div class="controls">
          <label class="select-wrap" for="collectMode">
            <span>Mode</span>
            <select id="collectMode">
              <option value="history" selected>history</option>
              <option value="last">last</option>
              <option value="types">types</option>
            </select>
          </label>
          <button id="runBtn" type="button" title="Ctrl/Cmd+Enter">Run</button>
        </div>
      </section>

      <section class="panel">
        <div class="panel-head">
          <div class="label">Output</div>
          <span class="status" id="runtimeStatus">Ready</span>
        </div>
        <div id="outputView" class="output-block"></div>
      </section>
    </section>

    <section class="panel">
      <div class="panel-head">
        <div class="label">Annotated</div>
      </div>
      <iframe
        id="annotatedFrame"
        class="annotated-frame"
        title="Lumitrace Annotated Output"
      ></iframe>
    </section>
  </main>

  <footer class="site-footer">
    <div class="footer-status">
      <span id="rubyStatus" class="status">Ruby.wasm loading</span>
    </div>
    <div class="footer-links">
      <span>Copyright (c) 2026 Koichi Sasada</span>
      <span><a href="https://github.com/ko1/lumitrace/tree/master/runv">(Repository)</a></span>
    </div>
  </footer>

  <script>
    const rubyStatus = document.getElementById('rubyStatus');
    if (window.location.protocol === 'file:') {
      rubyStatus.textContent = 'file:// ã§å‹•ãç’°å¢ƒã‚‚ã‚ã‚Šã¾ã™ã€‚å‹•ã‹ãªã„å ´åˆã¯ãƒ­ãƒ¼ã‚«ãƒ«ã‚µãƒ¼ãƒã§é–‹ã„ã¦ãã ã•ã„ã€‚';
      rubyStatus.className = 'status';
    }
    window.addEventListener('keydown', (event) => {
      if ((event.ctrlKey || event.metaKey) && event.key === 'Enter') {
        event.preventDefault();
        const runBtn = document.getElementById('runBtn');
        if (runBtn) runBtn.click();
      }
    });

    const rubyInput = document.getElementById('rubyInput');
    const rubyHighlight = document.getElementById('rubyHighlight');
    const updateRubyHighlight = () => {
      if (!rubyInput || !rubyHighlight) return;
      const code = rubyInput.value || '';
      if (window.hljs) {
        rubyHighlight.innerHTML = hljs.highlight(code, { language: 'ruby' }).value;
      } else {
        rubyHighlight.textContent = code;
      }
    };
    if (rubyInput && rubyHighlight) {
      rubyInput.addEventListener('input', updateRubyHighlight);
      rubyInput.addEventListener('scroll', () => {
        rubyHighlight.scrollTop = rubyInput.scrollTop;
        rubyHighlight.scrollLeft = rubyInput.scrollLeft;
      });
      updateRubyHighlight();
    }
  </script>

  <script src="https://cdn.jsdelivr.net/npm/@ruby/4.0-wasm-wasi@2.8.1/dist/browser.script.iife.js"></script>
  <script type="text/ruby">
    require "js"
    require "stringio"

    doc = JS.global[:document]
    ruby_input = doc.call(:getElementById, "rubyInput")
    run_btn = doc.call(:getElementById, "runBtn")
    collect_mode_input = doc.call(:getElementById, "collectMode")
    run_status = doc.call(:getElementById, "runStatus")
    runtime_status = doc.call(:getElementById, "runtimeStatus")
    ruby_status = doc.call(:getElementById, "rubyStatus")
    output_view = doc.call(:getElementById, "outputView")
    annotated_frame = doc.call(:getElementById, "annotatedFrame")

    if ruby_input.nil? || run_btn.nil? || collect_mode_input.nil? || run_status.nil? ||
       runtime_status.nil? || ruby_status.nil? || output_view.nil? || annotated_frame.nil?
      JS.global[:console].call(:error, "Ruby UI elements not found")
      return
    end

    ruby_status[:textContent] = "Ruby.wasm #{RUBY_VERSION} ready"
    ruby_status[:className] = "status ok"

    orig_stdout = $stdout
    orig_stderr = $stderr
    orig_stdin = $stdin

    # LUMITRACE_INLINE_BEGIN
    lumitrace_code = <<'LUMITRACE'
require "json"
require "prism"

module Lumitrace
  def self.R(id, value)
    raise "Lumitrace.R called before collect mode installation. Call Lumitrace.enable! first."
  end

module RecordInstrument
  SKIP_NODE_CLASSES = [
    Prism::DefNode,
    Prism::ClassNode,
    Prism::ModuleNode,
    Prism::IfNode,
    Prism::UnlessNode,
    Prism::WhileNode,
    Prism::UntilNode,
    Prism::ForNode,
    Prism::CaseNode,
    Prism::BeginNode,
    Prism::RescueNode,
    Prism::EnsureNode,
    Prism::AliasMethodNode,
    Prism::UndefNode
  ].freeze

  LITERAL_NODE_CLASSES = [
    Prism::IntegerNode,
    Prism::FloatNode,
    Prism::RationalNode,
    Prism::ImaginaryNode,
    Prism::StringNode,
    Prism::SymbolNode,
    Prism::TrueNode,
    Prism::FalseNode,
    Prism::NilNode
  ].freeze

  WRAP_NODE_CLASSES = [
    Prism::CallNode,
    Prism::YieldNode,
    Prism::LocalVariableReadNode,
    Prism::ItLocalVariableReadNode,
    Prism::ConstantReadNode,
    Prism::InstanceVariableReadNode,
    Prism::ClassVariableReadNode,
    Prism::GlobalVariableReadNode
  ].freeze

  def self.instrument_source(src, ranges, file_label: nil, record_method: "Lumitrace::R")
    file_label ||= "(unknown)"
    ranges = normalize_ranges(ranges)

    parse = Prism.parse(src)
    if parse.errors.any?
      raise "parse errors: #{parse.errors.map(&:message).join(", ") }"
    end

    inserts = collect_inserts(parse.value, src, ranges, file_label, record_method)

    modified = apply_insertions(src, inserts)
    if Lumitrace.respond_to?(:verbose_level) && Lumitrace.verbose_level >= 2
      Lumitrace.verbose_log("instrumented: #{file_label}", level: 2)
      if Lumitrace.verbose_level >= 3
        Lumitrace.verbose_log("instrumented_source: #{file_label}\n#{with_line_numbers(modified)}", level: 3)
      end
    end
    modified
  end

  def self.collect_locations_from_source(src, ranges)
    ranges = normalize_ranges(ranges || [])
    parse = Prism.parse(src)
    if parse.errors.any?
      raise "parse errors: #{parse.errors.map(&:message).join(", ") }"
    end

    locs = []
    seen_args = {}
    stack = [[parse.value, nil]]
    until stack.empty?
      node, parent = stack.pop
      next unless node

      if node.respond_to?(:location)
        line = node.location.start_line
        if in_ranges?(line, ranges) && wrap_expr?(node, parent)
          locs << expr_location(node).merge(kind: :expr)
        end
      end

      arg_locs = arg_locations_for_node(node, ranges)
      if arg_locs && !arg_locs.empty?
        arg_locs.each do |loc|
          key = [loc[:start_line], loc[:start_col], loc[:end_line], loc[:end_col], loc[:name]]
          next if seen_args[key]
          seen_args[key] = true
          locs << loc
        end
      end

      node.child_nodes.each { |child| stack << [child, node] }
    end
    locs
  end

  def self.with_line_numbers(source)
    lines = source.lines
    width = lines.length.to_s.length
    lines.each_with_index.map do |line, idx|
      format("%#{width}d| %s", idx + 1, line)
    end.join
  end

  def self.collect_inserts(root, src, ranges, file_label, record_method)
    inserts = []
    stack = [[root, nil]]

    until stack.empty?
      node, parent = stack.pop
      next unless node

      arg_insert = arg_insert_for_node(node, ranges, file_label, record_method, src)
      inserts << arg_insert if arg_insert

      if node.respond_to?(:location)
        line = node.location.start_line
        if in_ranges?(line, ranges) && wrap_expr?(node, parent)
          loc = expr_location(node)
          id = register_location(file_label, loc, kind: :expr)
          prefix = "#{record_method}(#{id}, ("
          suffix = "))"
          span_len = loc[:end_offset] - loc[:start_offset]
          inserts << { pos: loc[:start_offset], text: prefix, kind: :open, len: span_len }
          inserts << { pos: loc[:end_offset], text: suffix, kind: :close, len: span_len }
        end
      end

      node.child_nodes.each { |child| stack << [child, node] }
    end

    inserts
  end

  def self.normalize_ranges(ranges)
    ranges.map do |r|
      a = r[0].to_i
      b = r[1].to_i
      a <= b ? [a, b] : [b, a]
    end
  end

  def self.in_ranges?(line, ranges)
    return true if ranges.empty?
    ranges.any? { |(s, e)| line >= s && line <= e }
  end

  def self.apply_insertions(src, inserts)
    out = src.dup.b
    kind_order = { open: 0, close: 1, arg: 2 }
    inserts.sort_by do |i|
      [
        -i[:pos],
        kind_order[i[:kind]],
        i[:kind] == :open ? i[:len] : -i[:len]
      ]
    end.each do |i|
      out.insert(i[:pos], i[:text].b)
    end
    out.force_encoding(src.encoding)
  end

  def self.literal_value_node?(node)
    LITERAL_NODE_CLASSES.include?(node.class)
  end

  def self.wrap_expr?(node, parent = nil)
    return false unless node.respond_to?(:location)
    return false if literal_value_node?(node)
    if parent.is_a?(Prism::AliasGlobalVariableNode) || parent.is_a?(Prism::AliasMethodNode)
      return false
    end
    if parent.is_a?(Prism::DefNode) && parent.receiver == node
      return false
    end
    if parent.is_a?(Prism::EmbeddedVariableNode)
      return false
    end
    if parent.is_a?(Prism::ImplicitNode)
      return false
    end
    if node.is_a?(Prism::ConstantReadNode) &&
       (parent.is_a?(Prism::ClassNode) || parent.is_a?(Prism::ModuleNode))
      return false
    end
    WRAP_NODE_CLASSES.include?(node.class)
  end

  def self.expr_location(node)
    loc = node.location
    return {
      start_offset: loc.start_offset,
      end_offset: loc.start_offset + loc.length,
      start_line: loc.start_line,
      start_col: loc.start_column,
      end_line: loc.end_line,
      end_col: loc.end_column
    } unless node.is_a?(Prism::CallNode)

    best = loc
    [node.arguments&.location, node.block&.location, node.closing_loc].compact.each do |l|
      next unless l
      best = l if (l.start_offset + l.length) >= (best.start_offset + best.length)
    end

    {
      start_offset: loc.start_offset,
      end_offset: best.start_offset + best.length,
      start_line: loc.start_line,
      start_col: loc.start_column,
      end_line: best.end_line,
      end_col: best.end_column
    }
  end

  def self.has_block_with_body?(call_node)
    block = call_node.child_nodes.find { |n| n.is_a?(Prism::BlockNode) }
    block && block.body.is_a?(Prism::StatementsNode)
  end

  @events_by_id = []
  @loc_by_id = []
  @next_id = 0
  @max_samples_per_expr = 3
  @collect_mode = :last

  def self.max_samples_per_expr=(n)
    @max_samples_per_expr = n.to_i if n && n.to_i > 0
  end

  def self.max_samples_per_expr
    @max_samples_per_expr
  end

  def self.events_by_id
    @events_by_id
  end

  def self.collect_mode=(mode)
    @collect_mode = normalize_collect_mode(mode)
  end

  def self.collect_mode
    @collect_mode || :last
  end

  def self.normalize_collect_mode(mode)
    m = mode.to_s.strip
    m = "last" if m.empty?
    m = m.downcase
    case m
    when "last", "types", "history"
      m.to_sym
    else
      raise ArgumentError, "invalid collect mode: #{mode.inspect}"
    end
  end

  def self.reset_events!
    @events_by_id = []
  end

  def self.record_history(id, value)
    events_by_id = @events_by_id
    entry = events_by_id[id]
    if entry
      max = history_ring_size(entry)
      idx = entry[max]
      entry[idx] = value
      entry[max] = (idx + 1) % max
      entry[max + 1] += 1
      if (types = history_type_set(entry))
        type = value_type_name(value)
        types[type] = (types[type] || 0) + 1
      end
    else
      max = @max_samples_per_expr
      entry = Array.new(max + 3)
      entry[max] = max == 1 ? 0 : 1
      entry[max + 1] = 1
      entry[0] = value
      entry[max + 2] = { types: { value_type_name(value) => 1 } }
      events_by_id[id] = entry
    end
    value
  end

  def self.record_types(id, value)
    events_by_id = @events_by_id
    entry = events_by_id[id]
    if entry
      entry[:total] += 1
    else
      entry = { total: 1, types: {} }
      events_by_id[id] = entry
    end
    type = value_type_name(value)
    entry[:types][type] = (entry[:types][type] || 0) + 1
    value
  end

  def self.record_last(id, value)
    events_by_id = @events_by_id
    entry = events_by_id[id]
    if entry
      entry[:last_value] = value
      entry[:total] += 1
    else
      entry = { last_value: value, total: 1, types: {} }
      events_by_id[id] = entry
    end
    type = value_type_name(value)
    entry[:types][type] = (entry[:types][type] || 0) + 1
    value
  end

  def self.register_location(file, loc, kind: :expr, name: nil)
    @next_id += 1
    id = @next_id
    @loc_by_id[id] = {
      file: file,
      start_line: loc[:start_line],
      start_col: loc[:start_col],
      end_line: loc[:end_line],
      end_col: loc[:end_col],
      kind: kind,
      name: name
    }
    id
  end

  def self.events_from_ids
    out = []
    @events_by_id.each_with_index do |e, id|
      next unless e
      loc = @loc_by_id[id]
      next unless loc
      case collect_mode
      when :history
        raw_values = values_from_ring(e)
        all_types = history_type_set(e)
        if all_types.nil? || all_types.empty?
          all_types = {}
          raw_values.each do |v|
            t = value_type_name(v)
            all_types[t] = (all_types[t] || 0) + 1
          end
        end
        max = history_ring_size(e)
        out << {
          file: loc[:file],
          start_line: loc[:start_line],
          start_col: loc[:start_col],
          end_line: loc[:end_line],
          end_col: loc[:end_col],
          kind: loc[:kind].to_s,
          name: loc[:name],
          sampled_values: raw_values.map { |v| summarize_value(v, type: value_type_name(v)) },
          types: sorted_type_counts(all_types),
          total: e[max + 1]
        }
      when :types
        out << {
          file: loc[:file],
          start_line: loc[:start_line],
          start_col: loc[:start_col],
          end_line: loc[:end_line],
          end_col: loc[:end_col],
          kind: loc[:kind].to_s,
          name: loc[:name],
          types: sorted_type_counts(e[:types]),
          total: e[:total]
        }
      else # :last
        last_raw = e[:last_value]
        last_type = value_type_name(last_raw)
        out << {
          file: loc[:file],
          start_line: loc[:start_line],
          start_col: loc[:start_col],
          end_line: loc[:end_line],
          end_col: loc[:end_col],
          kind: loc[:kind].to_s,
          name: loc[:name],
          last_value: summarize_value(last_raw, type: last_type),
          types: sorted_type_counts(e[:types]),
          total: e[:total]
        }
      end
    end
    out
  end

  def self.values_from_ring(entry)
    max = history_ring_size(entry)
    idx = entry[max]
    total = entry[max + 1]
    len = total < max ? total : max
    return [] if len == 0

    start = idx - len
    start += max if start < 0
    out = []
    len.times do |i|
      out << entry[(start + i) % max]
    end
    out
  end

  def self.history_ring_size(entry)
    if entry[-1].is_a?(Hash) && entry[-1].key?(:types)
      entry.length - 3
    else
      entry.length - 2
    end
  end

  def self.history_type_set(entry)
    return nil unless entry[-1].is_a?(Hash)
    entry[-1][:types]
  end

  def self.dump_json(path = nil)
    path ||= File.expand_path("lumitrace_recorded.json", Dir.pwd)
    File.write(path, JSON.dump(events_from_ids), perm: 0o600)
    path
  end

  def self.dump_events_json(events, path = nil)
    path ||= File.expand_path("lumitrace_recorded.json", Dir.pwd)
    File.write(path, JSON.dump(events), perm: 0o600)
    path
  end

  def self.load_events_json(path)
    JSON.parse(File.read(path))
  end

  def self.merge_events(events, max_samples: nil)
    by_key = {}
    events.each do |e|
      file = e[:file] || e["file"]
      start_line = e[:start_line] || e["start_line"]
      start_col = e[:start_col] || e["start_col"]
      end_line = e[:end_line] || e["end_line"]
      end_col = e[:end_col] || e["end_col"]
      kind = e[:kind] || e["kind"]
      name = e[:name] || e["name"]
      total = e[:total] || e["total"] || 0
      mode = if e.key?(:sampled_values) || e.key?("sampled_values")
        :history
      elsif e.key?(:last_value) || e.key?("last_value")
        :last
      else
        :types
      end
      key = [file, start_line, start_col, end_line, end_col]
      entry = (by_key[key] ||= {
        file: file,
        start_line: start_line,
        start_col: start_col,
        end_line: end_line,
        end_col: end_col,
        kind: kind,
        name: name,
        mode: mode,
        sampled_values: [],
        last_value: nil,
        types: {},
        total: 0
      })

      entry[:mode] = mode if entry[:mode] != :history && mode == :history
      entry[:total] += total.to_i

      case mode
      when :history
        values = e[:sampled_values] || e["sampled_values"] || []
        normalized_values = values.map { |v| normalize_last_value(v) }
        entry[:sampled_values].concat(normalized_values)
        all_types = normalize_type_counts(e[:types] || e["types"])
        if all_types.empty?
          normalized_values.each do |v|
            next unless v
            t = v[:type] || v["type"]
            next unless t && !t.to_s.empty?
            tt = t.to_s
            entry[:types][tt] = (entry[:types][tt] || 0) + 1
          end
        else
          all_types.each { |t, c| entry[:types][t] = (entry[:types][t] || 0) + c }
        end
        if max_samples && max_samples.to_i > 0 && entry[:sampled_values].length > max_samples.to_i
          entry[:sampled_values] = entry[:sampled_values].last(max_samples.to_i)
        end
      when :last
        all_types = normalize_type_counts(e[:types] || e["types"])
        all_types.each { |t, c| entry[:types][t] = (entry[:types][t] || 0) + c }
        entry[:last_value] = normalize_last_value(e[:last_value] || e["last_value"])
      else
        all_types = normalize_type_counts(e[:types] || e["types"])
        all_types.each { |t, c| entry[:types][t] = (entry[:types][t] || 0) + c }
      end
    end
    by_key.values.map do |entry|
      out = {
        file: entry[:file],
        start_line: entry[:start_line],
        start_col: entry[:start_col],
        end_line: entry[:end_line],
        end_col: entry[:end_col],
        kind: entry[:kind],
        name: entry[:name],
        total: entry[:total]
      }
      case entry[:mode]
      when :history
        out[:sampled_values] = entry[:sampled_values]
        out[:types] = sorted_type_counts(entry[:types])
      when :last
        out[:last_value] = entry[:last_value]
        out[:types] = sorted_type_counts(entry[:types])
      else
        out[:types] = sorted_type_counts(entry[:types])
      end
      out
    end
  end

  def self.normalize_type_counts(types)
    return {} unless types
    case types
    when Hash
      out = {}
      types.each do |k, v|
        key = k.to_s
        next if key.empty?
        count = v.to_i
        count = 1 if count <= 0
        out[key] = (out[key] || 0) + count
      end
      out
    else
      arr = types.is_a?(String) ? [types] : Array(types)
      out = {}
      arr.each do |t|
        key = t.to_s
        next if key.empty?
        out[key] = (out[key] || 0) + 1
      end
      out
    end
  end

  def self.sorted_type_counts(types)
    normalize_type_counts(types).sort_by { |k, _v| k }.to_h
  end

  def self.normalize_last_value(last_value)
    return nil unless last_value
    return summarize_value(last_value) unless last_value.is_a?(Hash)

    fetch = lambda do |key|
      if last_value.key?(key)
        last_value[key]
      elsif last_value.key?(key.to_s)
        last_value[key.to_s]
      end
    end

    raw_value = fetch.call(:value)
    type = fetch.call(:type)
    preview = fetch.call(:preview)
    preview = fetch.call(:inspect) if preview.nil?
    if preview.nil?
      if !raw_value.nil?
        preview = raw_value.inspect
        type ||= value_type_name(raw_value)
      else
        preview = last_value.inspect
      end
    end
    type ||= "Object"

    out = {
      type: type.to_s,
      preview: preview.to_s
    }
    length = fetch.call(:length)
    out[:length] = length.to_i if length
    out
  end

  def self.merge_child_events(base_events, dir, max_samples: nil, logger: nil)
    return base_events unless dir && Dir.exist?(dir)
    files = Dir.glob(File.join(dir, "child_*.json"))
    return base_events if files.empty?

    logger&.call("merge: child_files=#{files.length}")
    merged = base_events.dup
    files.each do |path|
      begin
        data = load_events_json(path)
      rescue StandardError
        logger&.call("merge: skip unreadable #{path}")
        next
      end
      merged.concat(data)
      begin
        File.delete(path)
      rescue StandardError
        nil
      end
    end
    merge_events(merged, max_samples: max_samples)
  end

  def self.events
    events_from_ids
  end

  def self.safe_value(v)
    case v
    when Numeric, TrueClass, FalseClass, NilClass
      v
    else
      s = v.inspect
      s.bytesize > 1000 ? s[0, 1000] + "..." : s
    end
  end

  def self.value_type_name(v)
    name = v.class.name
    name && !name.empty? ? name : v.class.to_s
  end

  def self.summarize_value(v, type: nil)
    type ||= value_type_name(v)
    preview_limit = 120
    inspected = v.inspect
    if inspected.length > preview_limit
      {
        type: type,
        preview: "#{inspected[0, preview_limit]}...",
        length: inspected.length
      }
    else
      {
        type: type,
        preview: inspected
      }
    end
  end

  def self.definition_lines_from_source(src, ranges)
    ranges = normalize_ranges(ranges || [])
    parse = Prism.parse(src)
    if parse.errors.any?
      raise "parse errors: #{parse.errors.map(&:message).join(", ") }"
    end

    lines = {}
    stack = [parse.value]
    until stack.empty?
      node = stack.pop
      next unless node
      if node.is_a?(Prism::DefNode) && node.location
        line = node.location.start_line
        if in_ranges?(line, ranges)
          lines[line] = { endless: endless_def?(node) }
        end
      end
      node.child_nodes.each { |child| stack << child }
    end
    lines
  end

  def self.arg_locations_for_node(node, ranges)
    return [] unless node.is_a?(Prism::DefNode) || node.is_a?(Prism::BlockNode)
    return [] if endless_def?(node)
    params = parameters_for_node(node)
    return [] unless params
    arg_nodes = param_nodes_from(params)
    return [] if arg_nodes.empty?

    arg_nodes.each_with_object([]) do |pnode, out|
      next unless pnode.respond_to?(:location)
      name = param_name(pnode)
      next unless name
      loc = pnode.location
      line = loc.start_line
      next unless in_ranges?(line, ranges)
      out << {
        start_offset: loc.start_offset,
        end_offset: loc.start_offset + loc.length,
        start_line: loc.start_line,
        start_col: loc.start_column,
        end_line: loc.end_line,
        end_col: loc.end_column,
        kind: :arg,
        name: name
      }
    end
  end

  def self.arg_insert_for_node(node, ranges, file_label, record_method, src)
    return nil unless node.is_a?(Prism::DefNode) || node.is_a?(Prism::BlockNode)
    return nil if endless_def?(node)
    params = parameters_for_node(node)
    return nil unless params
    arg_nodes = param_nodes_from(params)
    return nil if arg_nodes.empty?
    body_offset = body_start_offset(node)
    used_fallback = false
    unless body_offset
      body_offset = arg_fallback_offset(node, params, src)
      used_fallback = true
    end

    records = []
    arg_nodes.each do |pnode|
      name = param_name(pnode)
      next unless name
      loc = pnode.location
      next unless loc
      line = loc.start_line
      next unless in_ranges?(line, ranges)
      id = register_location(file_label, {
        start_offset: loc.start_offset,
        end_offset: loc.start_offset + loc.length,
        start_line: loc.start_line,
        start_col: loc.start_column,
        end_line: loc.end_line,
        end_col: loc.end_column
      }, kind: :arg, name: name)
      records << "#{record_method}(#{id}, (#{name}))"
    end
    return nil if records.empty?
    prefix = used_fallback ? "; " : ""
    text = prefix + records.join("; ") + "; "
    { pos: body_offset, text: text, kind: :arg, len: 0 }
  end

  def self.arg_fallback_offset(node, params, src)
    if params.respond_to?(:location) && params.location
      pos = params.location.end_offset
      if node.is_a?(Prism::DefNode) && src
        pos += 1 if src.getbyte(pos) == ")".ord
      end
      return pos
    end
    if node.respond_to?(:opening_loc) && node.opening_loc
      return node.opening_loc.end_offset
    end
    nil
  end

  def self.endless_def?(node)
    return false unless node.is_a?(Prism::DefNode)
    node.respond_to?(:equal_loc) && node.equal_loc
  end

  def self.parameters_for_node(node)
    return node.parameters if node.is_a?(Prism::DefNode) || node.is_a?(Prism::BlockNode)
    nil
  end

  def self.body_start_offset(node)
    body = if node.respond_to?(:body)
      node.body
    else
      nil
    end
    return nil unless body && body.respond_to?(:location)
    if body.respond_to?(:statements) && body.statements&.body&.first&.location
      body.statements.body.first.location.start_offset
    else
      body.location.start_offset
    end
  end

  def self.param_nodes_from(params)
    nodes = []
    params.child_nodes.each do |child|
      nodes.concat(extract_param_nodes(child))
    end
    nodes
  end

  def self.extract_param_nodes(node)
    return [] unless node
    if node.respond_to?(:name)
      return [node]
    end
    if node.respond_to?(:parameters)
      return extract_param_nodes(node.parameters)
    end
    if node.respond_to?(:requireds)
      nodes = []
      nodes.concat(node.requireds) if node.requireds
      nodes.concat(node.optionals) if node.respond_to?(:optionals) && node.optionals
      nodes << node.rest if node.respond_to?(:rest) && node.rest
      nodes.concat(node.posts) if node.respond_to?(:posts) && node.posts
      nodes.concat(node.keywords) if node.respond_to?(:keywords) && node.keywords
      nodes << node.keyword_rest if node.respond_to?(:keyword_rest) && node.keyword_rest
      nodes << node.block if node.respond_to?(:block) && node.block
      return nodes.flat_map { |n| extract_param_nodes(n) }
    end
    if node.respond_to?(:target)
      return extract_param_nodes(node.target)
    end
    if node.respond_to?(:targets)
      return node.targets.flat_map { |t| extract_param_nodes(t) }
    end
    []
  end

  def self.param_name(node)
    return nil unless node.respond_to?(:name)
    name = node.name
    return nil if name.nil? || name == ""
    name.to_s
  end
end
end

if $PROGRAM_NAME == __FILE__
  path = ARGV[0] or abort "usage: ruby record_instrument.rb FILE RANGES_JSON [record_method] [out_path]"
  ranges = JSON.parse(ARGV[1] || "[]")
  record_method = ARGV[2] || "Lumitrace::R"
  out = RecordInstrument.instrument_source(File.read(path), ranges, file_label: path, record_method: record_method)

  if ARGV[3]
    File.write(ARGV[3], out)
  else
    puts out
  end
end

require "json"

module Lumitrace
module GenerateResultedHtml
  def self.render(source_path, events_path, ranges: nil, collect_mode: nil, max_samples: nil)
    unless File.exist?(events_path)
      abort "missing #{events_path}"
    end
    unless File.exist?(source_path)
      abort "missing #{source_path}"
    end

    raw_events = JSON.parse(File.read(events_path))
    mode_info = resolve_mode_info(raw_events, collect_mode: collect_mode, max_samples: max_samples)
    events = normalize_events(raw_events)
    events = add_missing_events(events, File.read(source_path), source_path, ranges)

    src = File.read(source_path)
    src_lines = src.lines
    ranges = normalize_ranges(ranges)
    expected_by_line, executed_by_line = line_stats(src, ranges, events, source_path)

    html_lines = []
    prev_lineno = nil
    first_lineno = nil
    last_lineno = nil
    src_lines.each_with_index do |line, idx|
      lineno = idx + 1
      next if ranges && !line_in_ranges?(lineno, ranges)
      first_lineno ||= lineno
      if prev_lineno && lineno > prev_lineno + 1
        html_lines << "<span class=\"line ellipsis\" data-line=\"...\"><span class=\"ln\">...</span></span>\n"
      end
      line_text = line.chomp
      evs = aggregate_events_for_line(events, lineno, line_text.length)
      expected = expected_by_line[lineno]
      executed = executed_by_line[lineno]
      line_class = line_class_for(expected, executed)
      if expected > 0 && executed == 0
        evs.each { |e| e[:suppress_miss] = true }
      end
      if evs.empty?
        html_lines << "<span class=\"line#{line_class}\" data-line=\"#{lineno}\"><span class=\"ln\">#{lineno}</span> #{esc(line_text)}</span>\n"
      else
        rendered = render_line_with_events(line_text, evs)
        html_lines << "<span class=\"line#{line_class}\" data-line=\"#{lineno}\"><span class=\"ln\">#{lineno}</span> #{rendered}</span>\n"
      end
      prev_lineno = lineno
      last_lineno = lineno
    end
    if first_lineno && first_lineno > 1
      html_lines.unshift("<span class=\"line ellipsis\" data-line=\"...\"><span class=\"ln\">...</span></span>\n")
    end
    if last_lineno && last_lineno < src_lines.length
      html_lines << "<span class=\"line ellipsis\" data-line=\"...\"><span class=\"ln\">...</span></span>\n"
    end

    <<~HTML
      <!doctype html>
      <html>
      <head>
        <meta charset="utf-8">
        <title>Recorded Result View</title>
        <style>
          body { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background: #f7f5f0; color: #1f1f1f; padding: 24px; }
          .code { background: #fffdf7; border: 1px solid #e5dfd0; border-radius: 8px; padding: 16px; line-height: 1.5; }
          .line { display: inline-block; width: 100%; box-sizing: border-box; padding: 2px 8px; }
          .line:hover { background: #fff2c6; }
          .line.hit { background: #f0ffe7; }
          .line.miss { background: #ffecec; }
          .line.ellipsis { color: #999; }
          .ln { display: inline-block; width: 3em; color: #888; user-select: none; }
          .hint { color: #666; margin-bottom: 4px; }
          .mode { color: #444; margin-bottom: 8px; }
          .expr { position: relative; display: inline-block; padding-bottom: 1px; }
          .expr.hit { }
          .expr.depth-1 { --hl: #7fbf7f; }
          .expr.depth-2 { --hl: #6fa8ff; }
          .expr.depth-3 { --hl: #ffb347; }
          .expr.depth-4 { --hl: #d78bff; }
          .expr.depth-5 { --hl: #ff6f91; }
          .expr.active { background: rgba(127, 191, 127, 0.15); box-shadow: inset 0 -2px var(--hl, #7fbf7f); }
          .expr.miss { background: rgba(255, 120, 120, 0.18); box-shadow: inset 0 -2px rgba(200, 120, 120, 0.6); }
          .marker { position: relative; display: inline-block; margin-left: 4px; cursor: help; font-size: 10px; line-height: 1; user-select: none; -webkit-user-select: none; -moz-user-select: none; }
          .marker.miss { color: #c07070; }
          .marker.arg { color: #2f6f8e; }
          .marker .tooltip {
            display: none;
            position: absolute;
            left: 0;
            top: 100%;
            margin-top: 4px;
            background: #2b2b2b;
            color: #fff;
            padding: 4px 6px;
            border-radius: 4px;
            font-size: 12px;
            white-space: pre;
            min-width: 16ch;
            max-width: 90vw;
            overflow-x: auto;
            overflow-y: hidden;
            z-index: 10;
            pointer-events: auto;
          }
          .marker:hover .tooltip,
          .marker:focus-within .tooltip,
          .marker .tooltip:hover { display: block; }
        </style>
      </head>
      <body>
        <div class="hint">Hover highlighted text to see recorded values.</div>
        <div class="mode">#{esc(mode_info[:text])}</div>
        <pre class="code"><code>
      #{html_lines.join("")}
        </code></pre>
      </body>
      </html>
    HTML
  end

  def self.esc(s)
    s.to_s
      .gsub("&", "&amp;")
      .gsub("<", "&lt;")
      .gsub(">", "&gt;")
      .gsub('"', "&quot;")
  end

  def self.detect_collect_mode(events)
    arr = Array(events)
    return "history" if arr.any? { |e| e.key?(:sampled_values) || e.key?("sampled_values") }
    return "last" if arr.any? { |e| e.key?(:last_value) || e.key?("last_value") }
    "types"
  end

  def self.infer_max_samples(events)
    max = Array(events).map do |e|
      values = e[:sampled_values] || e["sampled_values"]
      values.is_a?(Array) ? values.length : nil
    end.compact.max
    max && max > 0 ? max : nil
  end

  def self.resolve_mode_info(events, collect_mode: nil, max_samples: nil)
    mode = collect_mode.to_s.strip
    mode = detect_collect_mode(events) if mode.empty?
    samples = max_samples
    if mode == "history" && (samples.nil? || samples.to_i <= 0)
      samples = infer_max_samples(events)
    end
    text = case mode
    when "history"
      n = samples && samples.to_i > 0 ? samples.to_i : "N"
      unit = n == 1 ? "sample" : "samples"
      "Mode: history (last #{n} #{unit})"
    when "types"
      "Mode: types (type counts)"
    else
      "Mode: last (last value)"
    end
    { mode: mode, max_samples: samples, text: text }
  end

  def self.format_value(v, type: nil)
    value = case v
    when NilClass
      "nil"
    else
      v.to_s
    end
    type ||= value_type_name(v)
    "#{value} (#{type})"
  end

  def self.type_list_text(types, only_if_multiple: false)
    counts = normalize_type_counts(types)
    return nil if only_if_multiple && counts.length <= 1
    return "(no types)" if counts.empty?
    text = counts.sort_by { |k, _v| k }.map { |k, v| "#{k}(#{v})" }.join(", ")
    "types: #{text}"
  end

  def self.last_value_to_pair(last_value)
    return [nil, nil] unless last_value
    return [last_value, nil] unless last_value.is_a?(Hash)
    type = last_value[:type] || last_value["type"]
    if last_value.key?(:value) || last_value.key?("value")
      [last_value[:value] || last_value["value"], type]
    elsif last_value.key?(:preview) || last_value.key?("preview")
      [last_value[:preview] || last_value["preview"], type]
    elsif last_value.key?(:inspect) || last_value.key?("inspect")
      [last_value[:inspect] || last_value["inspect"], type]
    else
      [last_value.inspect, type]
    end
  end

  def self.value_type_name(v)
    name = v.class.name
    name && !name.empty? ? name : v.class.to_s
  end

  def self.render_line_with_events(line_text, events)
    opens = Hash.new { |h, k| h[k] = [] }
    closes = Hash.new { |h, k| h[k] = [] }

    events.each do |e|
      s = e[:start_col].to_i
      t = e[:end_col].to_i
      next if t <= s

      values = e[:sampled_values]
      all_types = e[:types]
      total = e[:total]
      label = if e[:kind].to_s == "arg" && e[:name]
        "arg #{e[:name]}"
      else
        nil
      end
      value_text = if total.to_i == 0
        label ? "#{label}: (not hit)" : "(not hit)"
      else
        summary = summarize_values(values, total, all_types: all_types)
        if label
          summary.empty? ? label : "#{label}: #{summary}"
        else
          summary
        end
      end
      tooltip_html = esc(value_text)
      depth_class = "depth-#{e[:depth]}"
      miss_class = total.to_i == 0 && !e[:suppress_miss] ? " miss" : ""
      key_attr = esc(e[:key_id])
      open_tag = "<span class=\"expr hit #{depth_class}#{miss_class}\" data-key=\"#{key_attr}\">"
      if e.fetch(:marker, true)
        marker = if total.to_i == 0
          "âˆ…"
        elsif e[:kind].to_s == "arg"
          "ðŸ§·"
        else
          "ðŸ”Ž"
        end
        marker_class = "marker"
        marker_class = "marker miss" if total.to_i == 0 && !e[:suppress_miss]
        marker_class = "#{marker_class} arg" if e[:kind].to_s == "arg"
        close_tag = "<span class=\"#{marker_class}\" data-key=\"#{key_attr}\" aria-hidden=\"true\">#{marker}<span class=\"tooltip\">#{tooltip_html}</span></span></span>"
      else
        close_tag = "</span>"
      end

      len = t - s
      opens[s] << { len: len, start: s, end: t, tag: open_tag }
      closes[t] << { len: len, start: s, end: t, tag: close_tag }
    end

    positions = (opens.keys + closes.keys).uniq.sort
    out = +""
    cursor = 0

    positions.each do |pos|
      out << esc(line_text[cursor...pos]) if pos > cursor
      if closes.key?(pos)
        closes[pos].sort_by { |c| [-c[:start], c[:len]] }.each { |c| out << c[:tag] }
      end
      if opens.key?(pos)
        opens[pos].sort_by { |o| -o[:end] }.each { |o| out << o[:tag] }
      end
      cursor = pos
    end

    out << esc(line_text[cursor..]) if cursor < line_text.length
    out
  end

  def self.comment_value_with_total_for_line(events)
    best = best_event_for_line(events)
    return nil unless best

    sampled_last = best[:sampled_values]&.last
    v, t = last_value_to_pair(sampled_last)
    all_types = best[:types]
    show_single_type = best[:sampled_values].nil? || best[:sampled_values].empty?
    type_text = type_list_text(all_types, only_if_multiple: !show_single_type)
    total = best[:total]
    value = if show_single_type
      type_text || ""
    else
      base = format_value(v, type: t)
      type_text ? "#{base} #{type_text}" : base
    end
    return nil if value.empty?
    if total && total > 1
      "#{value} (#{ordinal(total)} run)"
    else
      value
    end
  end

  def self.ordinal(n)
    n = n.to_i
    return n.to_s if n <= 0
    mod100 = n % 100
    suffix = if mod100 >= 11 && mod100 <= 13
      "th"
    else
      case n % 10
      when 1 then "st"
      when 2 then "nd"
      when 3 then "rd"
      else "th"
      end
    end
    "#{n}#{suffix}"
  end

  def self.best_event_for_line(events)
    return nil if events.empty?

    candidates = events.select { |e| e[:marker] && e[:kind].to_s != "arg" }
    return nil if candidates.empty?

    candidates.max_by do |e|
      span = e[:end_col].to_i - e[:start_col].to_i
      [span, e[:end_col].to_i, -e[:start_col].to_i]
    end
  end

  def self.summarize_values(values, total = nil, all_types: nil)
    if values.nil? || values.empty?
      multi = type_list_text(all_types, only_if_multiple: false)
      return multi if multi
      return ""
    end
    total ||= values.length
    last_vals = values.last(3)
    first_index = total - last_vals.length + 1
    lines = []
    extra = total - last_vals.length
    lines << "... (+#{extra} more)" if extra > 0
    last_vals.each_with_index do |v, i|
      idx = first_index + i
      value_text, type_text = last_value_to_pair(v)
      lines << "##{idx}: #{format_value(value_text, type: type_text)}"
    end
    multi = type_list_text(all_types, only_if_multiple: true)
    lines << multi if multi
    lines.join("\n")
  end

  def self.aggregate_events_for_line(events, lineno, line_len)
    buckets = {}
    spans = []

    events.each do |e|
      sline = e[:start_line]
      eline = e[:end_line]
      next if lineno < sline || lineno > eline

      if sline == eline
        s = e[:start_col]
        t = e[:end_col]
        marker = true
      else
        if lineno == sline
          s = e[:start_col]
          t = line_len
          marker = false
        elsif lineno == eline
          s = 0
          t = e[:end_col]
          marker = true
        else
          s = 0
          t = line_len
          marker = false
        end
      end

      next if t <= s
      spans << { start_col: s, end_col: t }
      key_id = e[:key].join(":")
      buckets[e[:key]] = {
        key: e[:key],
        key_id: key_id,
        start_col: s,
        end_col: t,
        marker: marker,
        kind: e[:kind],
        name: e[:name],
        sampled_values: e[:sampled_values],
        types: e[:types],
        total: e[:total]
      }
    end

    buckets.values.each do |b|
      depth = spans.count { |sp| b[:start_col] >= sp[:start_col] && b[:end_col] <= sp[:end_col] }
      b[:depth] = [[depth, 1].max, 5].min
    end

    buckets.values.sort_by { |b| b[:start_col] }
  end

  def self.line_class_for(expected, executed)
    return " hit" if executed > 0
    return " miss" if expected > 0
    ""
  end

  def self.normalize_events(events)
    merged = {}
    events.each do |e|
      file = e["file"] || e[:file]
      start_line = e["start_line"] || e[:start_line]
      start_col = e["start_col"] || e[:start_col]
      end_line = e["end_line"] || e[:end_line]
      end_col = e["end_col"] || e[:end_col]
      key = [
        file,
        start_line.to_i,
        start_col.to_i,
        end_line.to_i,
        end_col.to_i
      ]
      kind = e["kind"] || e[:kind] || "expr"
      name = e["name"] || e[:name]
      entry = (merged[key] ||= {
        key: key,
        file: key[0],
        start_line: key[1],
        start_col: key[2],
        end_line: key[3],
        end_col: key[4],
        kind: kind,
        name: name,
        sampled_values: [],
        types: {},
        total: 0
      })

      vals = e["sampled_values"] || e[:sampled_values] || []
      entry[:sampled_values].concat(vals)
      normalize_type_counts(e["types"] || e[:types]).each do |t, c|
        entry[:types][t] = (entry[:types][t] || 0) + c
      end
      if vals.empty?
        last_value = e["last_value"] || e[:last_value]
        entry[:sampled_values] << last_value if last_value
      end
      entry[:total] += (e["total"] || e[:total] || vals.length)
    end
    merged.each_value { |v| v[:types] = sorted_type_counts(v[:types]) }
    merged.values
  end

  def self.normalize_type_counts(types)
    return {} unless types
    case types
    when Hash
      out = {}
      types.each do |k, v|
        key = k.to_s
        next if key.empty?
        count = v.to_i
        count = 1 if count <= 0
        out[key] = (out[key] || 0) + count
      end
      out
    else
      arr = types.is_a?(String) ? [types] : Array(types)
      out = {}
      arr.each do |t|
        key = t.to_s
        next if key.empty?
        out[key] = (out[key] || 0) + 1
      end
      out
    end
  end

  def self.sorted_type_counts(types)
    normalize_type_counts(types).sort_by { |k, _v| k }.to_h
  end

  def self.normalize_ranges(ranges)
    return nil unless ranges
    ranges.map do |r|
      a = (r.respond_to?(:begin) ? r.begin : r[0]).to_i
      b = (r.respond_to?(:end) ? r.end : r[1]).to_i
      a <= b ? [a, b] : [b, a]
    end
  end

  def self.normalize_ranges_by_file(input)
    return nil unless input
    input.each_with_object({}) do |(file, ranges), h|
      abs = File.expand_path(file)
      if ranges.nil? || ranges.empty?
        h[abs] = []
      else
        h[abs] = normalize_ranges(ranges)
      end
    end
  end

  def self.line_in_ranges?(line, ranges)
    return true if ranges.empty?
    ranges.any? { |(s, e)| line >= s && line <= e }
  end

  def self.add_missing_events(events, source, filename, ranges)
    expected = RecordInstrument.collect_locations_from_source(source, ranges || [])
    existing = {}
    events.each do |e|
      key = [e[:file], e[:start_line], e[:start_col], e[:end_line], e[:end_col]]
      existing[key] = true
    end
      expected.each do |loc|
        key = [filename, loc[:start_line], loc[:start_col], loc[:end_line], loc[:end_col]]
        next if existing[key]
        events << {
          key: key,
          file: key[0],
          start_line: key[1],
          start_col: key[2],
          end_line: key[3],
          end_col: key[4],
          kind: loc[:kind],
          name: loc[:name],
          sampled_values: [],
          types: {},
          total: 0
        }
        existing[key] = true
      end
    events
  end

  def self.line_stats(source, ranges, events, filename)
    expected_by_line = Hash.new(0)
    RecordInstrument.collect_locations_from_source(source, ranges || []).each do |loc|
      (loc[:start_line]..loc[:end_line]).each do |line|
        expected_by_line[line] += 1
      end
    end
    executed_by_line = Hash.new(0)
    seen = {}
    events.each do |e|
      next unless e[:file] == filename
      key = [e[:start_line], e[:start_col], e[:end_line], e[:end_col]]
      next if seen[key]
      seen[key] = true
      if e[:total].to_i > 0
        (e[:start_line]..e[:end_line]).each do |line|
          executed_by_line[line] += 1
        end
      end
    end
    [expected_by_line, executed_by_line]
  end

  def self.render_all(events_path, root: Dir.pwd, ranges_by_file: nil, collect_mode: nil, max_samples: nil)
    raw_events = JSON.parse(File.read(events_path))
    render_all_from_events(raw_events, root: root, ranges_by_file: ranges_by_file, collect_mode: collect_mode, max_samples: max_samples)
  end

  def self.render_all_from_events(events, root: Dir.pwd, ranges_by_file: nil, collect_mode: nil, max_samples: nil)
    mode_info = resolve_mode_info(events, collect_mode: collect_mode, max_samples: max_samples)
    events = normalize_events(events)
    by_file = events.group_by { |e| e[:file] }
    ranges_by_file = normalize_ranges_by_file(ranges_by_file)

    target_paths = by_file.keys

    sections = target_paths.sort.map do |path|
      next unless File.exist?(path)
      src = File.read(path)
      if ranges_by_file
        next unless ranges_by_file.key?(path)
        ranges = ranges_by_file[path] || []
      else
        ranges = nil
      end
      file_events = add_missing_events((by_file[path] || []).dup, src, path, ranges)
      expected_by_line, executed_by_line = line_stats(src, ranges, file_events, path)
      html_lines = []
      prev_lineno = nil
      first_lineno = nil
      last_lineno = nil
      src.lines.each_with_index do |line, idx|
        lineno = idx + 1
        next if ranges && !line_in_ranges?(lineno, ranges)
        first_lineno ||= lineno
        if prev_lineno && lineno > prev_lineno + 1
          html_lines << "<span class=\"line ellipsis\" data-line=\"...\"><span class=\"ln\">...</span></span>\n"
        end
        line_text = line.chomp
        evs = aggregate_events_for_line(file_events, lineno, line_text.length)
        expected = expected_by_line[lineno]
        executed = executed_by_line[lineno]
        line_class = line_class_for(expected, executed)
        if expected > 0 && executed == 0
          evs.each { |e| e[:suppress_miss] = true }
        end
        if evs.empty?
          html_lines << "<span class=\"line#{line_class}\" data-line=\"#{lineno}\"><span class=\"ln\">#{lineno}</span> #{esc(line_text)}</span>\n"
        else
          rendered = render_line_with_events(line_text, evs)
          html_lines << "<span class=\"line#{line_class}\" data-line=\"#{lineno}\"><span class=\"ln\">#{lineno}</span> #{rendered}</span>\n"
        end
        prev_lineno = lineno
        last_lineno = lineno
      end
      if first_lineno && first_lineno > 1
        html_lines.unshift("<span class=\"line ellipsis\" data-line=\"...\"><span class=\"ln\">...</span></span>\n")
      end
      if last_lineno && last_lineno < src.lines.length
        html_lines << "<span class=\"line ellipsis\" data-line=\"...\"><span class=\"ln\">...</span></span>\n"
      end

      rel = path.start_with?(root) ? path.sub(root + File::SEPARATOR, "") : path
      <<~HTML
        <h2 class="file">#{esc(rel)}</h2>
        <pre class="code"><code>
      #{html_lines.join("")}
        </code></pre>
      HTML
    end.compact.join("\n")

    <<~HTML
      <!doctype html>
      <html>
      <head>
        <meta charset="utf-8">
        <title>Recorded Result View</title>
        <style>
          body { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background: #f7f5f0; color: #1f1f1f; padding: 24px; }
          .code { background: #fffdf7; border: 1px solid #e5dfd0; border-radius: 8px; padding: 16px; line-height: 1.5; }
          .line { display: inline-block; width: 100%; box-sizing: border-box; padding: 2px 8px; }
          .line:hover { background: #fff2c6; }
          .line.hit { background: #f0ffe7; }
          .line.miss { background: #ffecec; }
          .line.ellipsis { color: #999; }
          .ln { display: inline-block; width: 3em; color: #888; user-select: none; }
          .hint { color: #666; margin-bottom: 4px; }
          .mode { color: #444; margin-bottom: 8px; }
          .file { margin: 24px 0 8px; font-size: 16px; color: #333; }
          .expr { position: relative; display: inline-block; padding-bottom: 1px; }
          .expr.hit { }
          .expr.depth-1 { --hl: #7fbf7f; }
          .expr.depth-2 { --hl: #6fa8ff; }
          .expr.depth-3 { --hl: #ffb347; }
          .expr.depth-4 { --hl: #d78bff; }
          .expr.depth-5 { --hl: #ff6f91; }
          .expr.active { background: rgba(127, 191, 127, 0.15); box-shadow: inset 0 -2px var(--hl, #7fbf7f); }
          .expr.miss { background: rgba(255, 120, 120, 0.18); box-shadow: inset 0 -2px rgba(200, 120, 120, 0.6); }
          .marker { position: relative; display: inline-block; margin-left: 4px; cursor: help; font-size: 10px; line-height: 1; user-select: none; -webkit-user-select: none; -moz-user-select: none; }
          .marker.miss { color: #c07070; }
          .marker.arg { color: #2f6f8e; }
          .marker .tooltip {
            display: none;
            position: absolute;
            left: 0;
            top: 100%;
            margin-top: 4px;
            background: #2b2b2b;
            color: #fff;
            padding: 4px 6px;
            border-radius: 4px;
            font-size: 12px;
            white-space: pre;
            min-width: 16ch;
            max-width: 90vw;
            overflow-x: auto;
            overflow-y: hidden;
            z-index: 10;
            pointer-events: auto;
          }
          .marker:hover .tooltip,
          .marker:focus-within .tooltip,
          .marker .tooltip:hover { display: block; }
        </style>
      </head>
      <body>
        <div class="hint">Hover highlighted text to see recorded values.</div>
        <div class="mode">#{esc(mode_info[:text])}</div>
        #{sections}
        <script>
          (function() {
            document.querySelectorAll('.marker').forEach(marker => {
              marker.addEventListener('mouseenter', () => {
                document.querySelectorAll('.expr').forEach(e => e.classList.remove('active'));
                const key = marker.dataset.key;
                if (key) {
                  document.querySelectorAll(`.expr[data-key="${key}"]`).forEach(e => e.classList.add('active'));
                } else {
                  marker.closest('.expr')?.classList.add('active');
                }
              });
              marker.addEventListener('mouseleave', () => {
                const key = marker.dataset.key;
                if (key) {
                  document.querySelectorAll(`.expr[data-key="${key}"]`).forEach(e => e.classList.remove('active'));
                } else {
                  marker.closest('.expr')?.classList.remove('active');
                }
              });
            });
          })();
        #{'</scr' + 'ipt>'}
      </body>
      </html>
    HTML
  end

  def self.render_source_from_events(source, events, filename: "script.rb", ranges: nil, collect_mode: nil, max_samples: nil)
    mode_info = resolve_mode_info(events, collect_mode: collect_mode, max_samples: max_samples)
    events = normalize_events(events)
    ranges = normalize_ranges(ranges)
    target_events = add_missing_events(events.select { |e| e[:file] == filename }, source, filename, ranges)
    expected_by_line, executed_by_line = line_stats(source, ranges, target_events, filename)

    html_lines = []
    prev_lineno = nil
    first_lineno = nil
    last_lineno = nil
    source.lines.each_with_index do |line, idx|
      lineno = idx + 1
      next if ranges && !line_in_ranges?(lineno, ranges)
      first_lineno ||= lineno
      if prev_lineno && lineno > prev_lineno + 1
        html_lines << "<span class=\"line ellipsis\" data-line=\"...\"><span class=\"ln\">...</span></span>\n"
      end
      line_text = line.chomp
      evs = aggregate_events_for_line(target_events, lineno, line_text.length)
      expected = expected_by_line[lineno]
      executed = executed_by_line[lineno]
      line_class = line_class_for(expected, executed)
      if expected > 0 && executed == 0
        evs.each { |e| e[:suppress_miss] = true }
      end
      if evs.empty?
        html_lines << "<span class=\"line#{line_class}\" data-line=\"#{lineno}\"><span class=\"ln\">#{lineno}</span> #{esc(line_text)}</span>\n"
      else
        rendered = render_line_with_events(line_text, evs)
        html_lines << "<span class=\"line#{line_class}\" data-line=\"#{lineno}\"><span class=\"ln\">#{lineno}</span> #{rendered}</span>\n"
      end
      prev_lineno = lineno
      last_lineno = lineno
    end
    if first_lineno && first_lineno > 1
      html_lines.unshift("<span class=\"line ellipsis\" data-line=\"...\"><span class=\"ln\">...</span></span>\n")
    end
    if last_lineno && last_lineno < source.lines.length
      html_lines << "<span class=\"line ellipsis\" data-line=\"...\"><span class=\"ln\">...</span></span>\n"
    end

    <<~HTML
      <!doctype html>
      <html>
      <head>
        <meta charset="utf-8">
        <title>Recorded Result View</title>
        <style>
          body { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background: #f7f5f0; color: #1f1f1f; padding: 24px; }
          .code { background: #fffdf7; border: 1px solid #e5dfd0; border-radius: 8px; padding: 16px; line-height: 1.5; }
          .line { display: inline-block; width: 100%; box-sizing: border-box; padding: 2px 8px; }
          .line:hover { background: #fff2c6; }
          .line.hit { background: #f0ffe7; }
          .line.miss { background: #ffecec; }
          .line.ellipsis { color: #999; }
          .ln { display: inline-block; width: 3em; color: #888; user-select: none; }
          .hint { color: #666; margin-bottom: 4px; }
          .mode { color: #444; margin-bottom: 8px; }
          .file { margin: 24px 0 8px; font-size: 16px; color: #333; }
          .expr { position: relative; display: inline-block; padding-bottom: 1px; }
          .expr.hit { }
          .expr.depth-1 { --hl: #7fbf7f; }
          .expr.depth-2 { --hl: #6fa8ff; }
          .expr.depth-3 { --hl: #ffb347; }
          .expr.depth-4 { --hl: #d78bff; }
          .expr.depth-5 { --hl: #ff6f91; }
          .expr.active { background: rgba(127, 191, 127, 0.15); box-shadow: inset 0 -2px var(--hl, #7fbf7f); }
          .expr.miss { background: rgba(255, 120, 120, 0.18); box-shadow: inset 0 -2px rgba(200, 120, 120, 0.6); }
          .marker { position: relative; display: inline-block; margin-left: 4px; cursor: help; font-size: 10px; line-height: 1; user-select: none; -webkit-user-select: none; -moz-user-select: none; }
          .marker.miss { color: #c07070; }
          .marker.arg { color: #2f6f8e; }
          .marker .tooltip {
            display: none;
            position: absolute;
            left: 0;
            top: 100%;
            margin-top: 4px;
            background: #2b2b2b;
            color: #fff;
            padding: 4px 6px;
            border-radius: 4px;
            font-size: 12px;
            white-space: pre;
            min-width: 16ch;
            max-width: 90vw;
            overflow-x: auto;
            overflow-y: hidden;
            z-index: 10;
            pointer-events: auto;
          }
          .marker:hover .tooltip,
          .marker:focus-within .tooltip,
          .marker .tooltip:hover { display: block; }
        </style>
      </head>
      <body>
        <div class="hint">Hover highlighted text to see recorded values.</div>
        <div class="mode">#{esc(mode_info[:text])}</div>
        <h2 class="file">#{esc(filename)}</h2>
        <pre class="code"><code>
      #{html_lines.join("")}
        </code></pre>
        <script>
          (function() {
            document.querySelectorAll('.marker').forEach(marker => {
              marker.addEventListener('mouseenter', () => {
                document.querySelectorAll('.expr').forEach(e => e.classList.remove('active'));
                const key = marker.dataset.key;
                if (key) {
                  document.querySelectorAll(`.expr[data-key="${key}"]`).forEach(e => e.classList.add('active'));
                } else {
                  marker.closest('.expr')?.classList.add('active');
                }
              });
              marker.addEventListener('mouseleave', () => {
                const key = marker.dataset.key;
                if (key) {
                  document.querySelectorAll(`.expr[data-key="${key}"]`).forEach(e => e.classList.remove('active'));
                } else {
                  marker.closest('.expr')?.classList.remove('active');
                }
              });
            });
          })();
        #{'</scr' + 'ipt>'}
      </body>
      </html>
    HTML
  end

  def self.render_text_from_events(source, events, filename: "script.rb", ranges: nil, with_header: true, header_label: nil, tty: nil)
    events = normalize_events(events)
    ranges = normalize_ranges(ranges)
    target_events = events.select { |e| e[:file] == filename }
    term_width = tty ? terminal_width : nil
    def_lines = RecordInstrument.definition_lines_from_source(source, ranges)

    expected_by_line = Hash.new(0)
    RecordInstrument.collect_locations_from_source(source, ranges).each do |loc|
      expected_by_line[loc[:start_line]] += 1
    end
    executed_by_line = Hash.new(0)
    seen = {}
    target_events.each do |e|
      line = e[:start_line] || e["start_line"]
      key = [
        e[:start_line] || e["start_line"],
        e[:start_col] || e["start_col"],
        e[:end_line] || e["end_line"],
        e[:end_col] || e["end_col"]
      ]
      next if seen[key]
      seen[key] = true
      executed_by_line[line] += 1 if line
    end

    out = +""
    if with_header
      label = header_label || filename
      if ranges && !ranges.empty?
        label = "#{label} (lines: #{format_ranges(ranges)})"
      end
      out << "### #{label}\n"
    end

    total_lines = source.lines.length
    ln_width = total_lines.to_s.length
    prefix_for = ->(n, missing) { "#{missing ? "!" : " "}#{format("%#{ln_width}d| ", n)}" }

    raw_lines = source.lines.each_with_index.flat_map do |line, idx|
      lineno = idx + 1
      next if ranges && !line_in_ranges?(lineno, ranges)
      line_text = line.chomp
      evs = aggregate_events_for_line(target_events, lineno, line_text.length)
      def_info = def_lines[lineno]
      comment_value = def_info && !def_info[:endless] ? nil : comment_value_with_total_for_line(evs)
      missing = expected_by_line[lineno] > 0 && executed_by_line[lineno] == 0
      [{ lineno: lineno, text: line_text, comment: comment_value, prefix: prefix_for.call(lineno, missing) }]
    end.compact

    group = []
    flush_group = lambda do
      return if group.empty?
      max_len = group.map { |l| l[:text].length }.max || 0
      group.each do |l|
        if l[:comment] && !l[:comment].to_s.empty?
          pad = " " * (max_len - l[:text].length)
          line_prefix = "#{l[:prefix]}#{l[:text]}#{pad} #=> "
          comment = l[:comment].to_s
          if term_width && term_width > 0
            available = term_width - line_prefix.length
            if available > 0
              if comment.length > available
                if available >= 3
                  comment = comment[0, available - 3] + "..."
                else
                  comment = comment[0, available]
                end
              end
              out << "#{line_prefix}#{comment}\n"
            else
              out << "#{l[:prefix]}#{l[:text]}\n"
            end
          else
            out << "#{line_prefix}#{comment}\n"
          end
        else
          out << "#{l[:prefix]}#{l[:text]}\n"
        end
      end
      group.clear
    end

    prev_lineno = nil
    first_lineno = raw_lines.first && raw_lines.first[:lineno]
    last_lineno = raw_lines.last && raw_lines.last[:lineno]
    if first_lineno && first_lineno > 1
      out << "...\n"
    end
    raw_lines.each do |l|
      if prev_lineno && l[:lineno] > prev_lineno + 1
        flush_group.call
        out << "...\n"
      end
      if l[:text].strip.empty?
        flush_group.call
        out << "#{l[:prefix]}#{l[:text]}\n"
      else
        group << l
      end
      prev_lineno = l[:lineno]
    end
    flush_group.call
    if last_lineno
      total_lines = source.lines.length
      out << "...\n" if last_lineno < total_lines
    end

    out
  end

  def self.terminal_width
    cols = ENV["COLUMNS"].to_i
    return cols if cols > 0
    begin
      require "io/console"
      return IO.console.winsize[1] if IO.respond_to?(:console) && IO.console
    rescue StandardError
      nil
    end
    nil
  end

  def self.render_text_all_from_events(events, root: Dir.pwd, ranges_by_file: nil, tty: nil)
    events = normalize_events(events)
    by_file = events.group_by { |e| e[:file] }
    ranges_by_file = normalize_ranges_by_file(ranges_by_file)

    sections = by_file.keys.sort.map do |path|
      next unless File.exist?(path)
      src = File.read(path)
      if ranges_by_file
        next unless ranges_by_file.key?(path)
        ranges = ranges_by_file[path] || []
      else
        ranges = nil
      end
      rel = path.start_with?(root) ? path.sub(root + File::SEPARATOR, "") : path
      render_text_from_events(src, events, filename: path, ranges: ranges, with_header: true, header_label: rel, tty: tty)
    end.compact

    header = "\n=== Lumitrace Results (text) ===\n\n"
    header + sections.join("\n")
  end

  def self.format_ranges(ranges)
    ranges.map { |(s, e)| s == e ? s.to_s : "#{s}-#{e}" }.join(", ")
  end
end

if $PROGRAM_NAME == __FILE__
  source_path = ARGV[0] or abort "usage: ruby generate_resulted_html.rb SOURCE_PATH EVENTS_PATH"
  events_path = ARGV[1] or abort "usage: ruby generate_resulted_html.rb SOURCE_PATH EVENTS_PATH"
  puts GenerateResultedHtml.render(source_path, events_path)
end
end
LUMITRACE
    # LUMITRACE_INLINE_END

    ensure_lumitrace = lambda do
      return if defined?(Lumitrace::RecordInstrument) && defined?(Lumitrace::GenerateResultedHtml)
      eval(lumitrace_code, TOPLEVEL_BINDING, "lumitrace_inline.rb")
    end

    install_collect_mode = lambda do |mode|
      normalized = mode.to_s
      normalized = "history" unless %w[last types history].include?(normalized)
      Lumitrace.define_singleton_method(:R) do |id, value|
        case normalized
        when "last"
          Lumitrace::RecordInstrument.record_last(id, value)
        when "types"
          Lumitrace::RecordInstrument.record_types(id, value)
        else
          Lumitrace::RecordInstrument.record_history(id, value)
        end
      end
      Lumitrace::RecordInstrument.collect_mode = normalized.to_sym
      normalized
    end

    set_status = lambda do |node, text, kind = nil|
      node[:textContent] = text
      node[:className] = kind ? "status #{kind}" : "status"
    end

    run_code = lambda do
      run_btn[:disabled] = true
      set_status.call(run_status, "Running...")
      set_status.call(runtime_status, "Executing...")
      output_view[:textContent] = ""

      out = StringIO.new
      err = StringIO.new
      input = StringIO.new("")
      source = ruby_input[:value].to_s
      selected_mode = collect_mode_input[:value].to_s
      annotated_html = ""

      begin
        $stdout = out
        $stderr = err
        $stdin = input

        Object.send(:remove_const, :STDIN) if Object.const_defined?(:STDIN)
        Object.send(:remove_const, :STDOUT) if Object.const_defined?(:STDOUT)
        Object.send(:remove_const, :STDERR) if Object.const_defined?(:STDERR)
        STDIN = $stdin
        STDOUT = $stdout
        STDERR = $stderr

        ensure_lumitrace.call
        selected_mode = install_collect_mode.call(selected_mode)
        Lumitrace::RecordInstrument.reset_events!
        Lumitrace::RecordInstrument.instance_variable_set(:@loc_by_id, [])
        Lumitrace::RecordInstrument.instance_variable_set(:@next_id, 0)
        instrumented = Lumitrace::RecordInstrument.instrument_source(source, [], file_label: "script.rb")
        eval(instrumented, TOPLEVEL_BINDING, "script.rb")
      rescue Exception => e
        err.puts("#{e.class}: #{e.message}")
        if e.backtrace
          err.puts(e.backtrace.join("\\n"))
        end
      ensure
        combined = out.string
        combined += err.string if err.string && err.string != ""
        output_view[:textContent] = combined
        begin
          events = Lumitrace::RecordInstrument.events
          annotated_html = Lumitrace::GenerateResultedHtml.render_source_from_events(
            source,
            events,
            filename: "script.rb",
            collect_mode: selected_mode,
            max_samples: Lumitrace::RecordInstrument.max_samples_per_expr
          )
        rescue Exception => e
          annotated_html = "<pre>Annotated render error: #{e.class}: #{e.message}</pre>"
        end
        annotated_frame[:srcdoc] = annotated_html

        $stdout = orig_stdout
        $stderr = orig_stderr
        $stdin = orig_stdin

        Object.send(:remove_const, :STDIN) if Object.const_defined?(:STDIN)
        Object.send(:remove_const, :STDOUT) if Object.const_defined?(:STDOUT)
        Object.send(:remove_const, :STDERR) if Object.const_defined?(:STDERR)
        STDIN = orig_stdin
        STDOUT = orig_stdout
        STDERR = orig_stderr
      end

      set_status.call(run_status, "Done", "ok")
      set_status.call(runtime_status, "Finished", "ok")
      run_btn[:disabled] = false
    end

    run_btn.call(:addEventListener, "click") { run_code.call }
  </script>

  <script>
    const annotatedFrame = document.getElementById('annotatedFrame');
    if (annotatedFrame) {
      annotatedFrame.addEventListener('load', () => {
        try {
          const doc = annotatedFrame.contentDocument;
          if (!doc) return;
          const clearActive = () => {
            doc.querySelectorAll('.expr.active').forEach(e => e.classList.remove('active'));
          };
          doc.querySelectorAll('.marker').forEach(marker => {
            marker.addEventListener('mouseenter', () => {
              clearActive();
              const expr = marker.closest('.expr');
              if (expr) expr.classList.add('active');
            });
            marker.addEventListener('mouseleave', () => {
              const expr = marker.closest('.expr');
              if (expr) expr.classList.remove('active');
            });
          });
        } catch (_) {
          // Cross-origin or iframe not ready.
        }
      });
    }
  </script>
</body>
</html>
